{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Espresso Kotlin Playground What is this? A mini series on the different strategies from playing around with Espresso and Kotlin to help accelerate the development of writing expressive tests. How to read The series of topics was intended to be read sequentially to continuously build off the topics being covered. So if you came in at a random place and don't understand what's going on, it might help to start from the beginning from the page object pattern . What you will learn Page Object Pattern - abstract out the logic of interacting with a page in the UI from the test Espresso Extensions - a collection of Kotlin extension functions that help reduce some of the boiler plate in view matching/interactions and provide better code completion when building out page objects Navigation DSL - create a domain specific language for navigating between the different page objects in a test Mock Tests Mockk Test - write a test with a mocked dependency using Mockk Mock Ktor Test - write a mock network test using Ktor network client and Mock Engine . Also learn how to use Espresso idling resources to deal with code that runs on the IO thread and can cause flaky tests. Onward I hope you learn something from this series and please leave any comments about the series on my website. If there's any suggestions to improve anything, feel free to open up a issue on the project. Otherwise, enjoy! Info If you would like to follow along by coding, checkout the project and switch to 1-start branch. The project starts off from the Login Activity template in the setup wizard. git clone https://github.com/plusmobileapps/espresso-kotlin-playground.git git checkout 1 -start","title":"Welcome"},{"location":"#welcome-to-espresso-kotlin-playground","text":"","title":"Welcome to Espresso Kotlin Playground"},{"location":"#what-is-this","text":"A mini series on the different strategies from playing around with Espresso and Kotlin to help accelerate the development of writing expressive tests.","title":"What is this?"},{"location":"#how-to-read","text":"The series of topics was intended to be read sequentially to continuously build off the topics being covered. So if you came in at a random place and don't understand what's going on, it might help to start from the beginning from the page object pattern .","title":"How to read"},{"location":"#what-you-will-learn","text":"Page Object Pattern - abstract out the logic of interacting with a page in the UI from the test Espresso Extensions - a collection of Kotlin extension functions that help reduce some of the boiler plate in view matching/interactions and provide better code completion when building out page objects Navigation DSL - create a domain specific language for navigating between the different page objects in a test Mock Tests Mockk Test - write a test with a mocked dependency using Mockk Mock Ktor Test - write a mock network test using Ktor network client and Mock Engine . Also learn how to use Espresso idling resources to deal with code that runs on the IO thread and can cause flaky tests.","title":"What you will learn"},{"location":"#onward","text":"I hope you learn something from this series and please leave any comments about the series on my website. If there's any suggestions to improve anything, feel free to open up a issue on the project. Otherwise, enjoy! Info If you would like to follow along by coding, checkout the project and switch to 1-start branch. The project starts off from the Login Activity template in the setup wizard. git clone https://github.com/plusmobileapps/espresso-kotlin-playground.git git checkout 1 -start","title":"Onward"},{"location":"espresso-extensions/","text":"Espresso Extensions Espresso was originally written in Java which can be verbose and makes heavy use of static functions which do not always show up as suggestions when trying to use code completion. Since these tests are written in Kotlin, extension functions can be utilized to help improve the developer experience in writing expressive tests that provide helpful code completion. ViewInteraction Extension One of the most common ways to create a ViewInteraction with a View id is onView(withId(R.id.some_id)) . To simplify this construction in page objects, an extension function can be added to the BasePage interface on an Int (resource id) which will return the ViewInteraction . import androidx.test.espresso.ViewInteraction import androidx.test.espresso.matcher.ViewMatchers.withId interface BasePage { fun Int . toViewInteraction (): ViewInteraction = onView ( withId ( this )) } Now the LoginPage can take advantage of the extension function for the implementation detail of the page objects. class LoginPage : BasePage { fun onEmail (): ViewInteraction = R . id . username . toViewInteraction () fun onPassword (): ViewInteraction = R . id . password . toViewInteraction () fun onSignInOrRegisterButton (): ViewInteraction = R . id . login . toViewInteraction () } ViewAction Extensions There are many of different types of actions that could be taken on a View, this series makes use of the following extension functions on a ViewInteraction in order to write more expressive tests. If you need a different type of action, the pattern should still apply simply creating an extension function on ViewInteraction . Visibility fun ViewInteraction . verifyVisible (): ViewInteraction = check ( matches ( isDisplayed ())) The assertScreen() function in each page can be implemented using the visibility extension function. class LoginUI : BaseUI { override fun assertScreen () { onEmail (). verifyVisible () onPassword (). verifyVisible () onSignInOrRegisterButton (). verifyVisible () } } Text Fields fun ViewInteraction . typeText ( text : String ): ViewInteraction = perform ( ViewActions . typeText ( text )) fun ViewInteraction . verifyTextFieldError ( @StringRes resId : Int ): ViewInteraction = check ( matches ( hasErrorText ( getString ( resId )))) // Helper function for getting strings using application target context fun getString ( @StringRes resId : Int ): String = InstrumentationRegistry . getInstrumentation (). targetContext . getString ( resId ) One sample usage might be for a test that verifies an error is shown on a password field if not enough characters were entered. LoginPage (). apply { onPassword (). typeText ( \"4344\" ) onEmail (). typeText ( \"andrew@test.com\" ) onPassword (). verifyTextFieldError ( R . string . invalid_password ) } Clicking fun ViewInteraction . click (): ViewInteraction = perform ( ViewActions . click ()) Sample: LoginPage (). onSignInOrRegisterButton (). click () Verify Text fun ViewInteraction . verifyText ( text : String ): ViewInteraction = check ( matches ( withText ( text ))) Sample: LoggedInPage (). onWelcomeGreeting (). verifyText ( \"Welcome Andrew!\" ) androidx.test:core-ktx androidTestImplementation \"androidx.test:core-ktx:<version>\" Versions Sample: val scenario = launchActivity < LoginActivity > () Simple Test Now that all of the page objects are implemented, the last login test can be simplified further using the new extension functions. @Test fun successfulLogin () { val scenario = launchActivity < LoginActivity > () LoginPage (). apply { onEmail (). typeText ( \"andrew@test.com\" ) onPassword (). typeText ( \"password123\" ) onSignInOrRegisterButton (). click () } LoggedInPage (). onWelcomeGreeting (). verifyText ( \"Welcome Andrew!\" ) } The test is starting to look better, however each page has to be instantiated and there is no link between pages when writing tests. Thankfully Kotlin has features that will be covered in the next section to create a navigation DSL. Resources Source code Github commit 3-espresso-extensions - GitHub Branch","title":"Espresso Extensions"},{"location":"espresso-extensions/#espresso-extensions","text":"Espresso was originally written in Java which can be verbose and makes heavy use of static functions which do not always show up as suggestions when trying to use code completion. Since these tests are written in Kotlin, extension functions can be utilized to help improve the developer experience in writing expressive tests that provide helpful code completion.","title":"Espresso Extensions"},{"location":"espresso-extensions/#viewinteraction-extension","text":"One of the most common ways to create a ViewInteraction with a View id is onView(withId(R.id.some_id)) . To simplify this construction in page objects, an extension function can be added to the BasePage interface on an Int (resource id) which will return the ViewInteraction . import androidx.test.espresso.ViewInteraction import androidx.test.espresso.matcher.ViewMatchers.withId interface BasePage { fun Int . toViewInteraction (): ViewInteraction = onView ( withId ( this )) } Now the LoginPage can take advantage of the extension function for the implementation detail of the page objects. class LoginPage : BasePage { fun onEmail (): ViewInteraction = R . id . username . toViewInteraction () fun onPassword (): ViewInteraction = R . id . password . toViewInteraction () fun onSignInOrRegisterButton (): ViewInteraction = R . id . login . toViewInteraction () }","title":"ViewInteraction Extension"},{"location":"espresso-extensions/#viewaction-extensions","text":"There are many of different types of actions that could be taken on a View, this series makes use of the following extension functions on a ViewInteraction in order to write more expressive tests. If you need a different type of action, the pattern should still apply simply creating an extension function on ViewInteraction .","title":"ViewAction Extensions"},{"location":"espresso-extensions/#visibility","text":"fun ViewInteraction . verifyVisible (): ViewInteraction = check ( matches ( isDisplayed ())) The assertScreen() function in each page can be implemented using the visibility extension function. class LoginUI : BaseUI { override fun assertScreen () { onEmail (). verifyVisible () onPassword (). verifyVisible () onSignInOrRegisterButton (). verifyVisible () } }","title":"Visibility"},{"location":"espresso-extensions/#text-fields","text":"fun ViewInteraction . typeText ( text : String ): ViewInteraction = perform ( ViewActions . typeText ( text )) fun ViewInteraction . verifyTextFieldError ( @StringRes resId : Int ): ViewInteraction = check ( matches ( hasErrorText ( getString ( resId )))) // Helper function for getting strings using application target context fun getString ( @StringRes resId : Int ): String = InstrumentationRegistry . getInstrumentation (). targetContext . getString ( resId ) One sample usage might be for a test that verifies an error is shown on a password field if not enough characters were entered. LoginPage (). apply { onPassword (). typeText ( \"4344\" ) onEmail (). typeText ( \"andrew@test.com\" ) onPassword (). verifyTextFieldError ( R . string . invalid_password ) }","title":"Text Fields"},{"location":"espresso-extensions/#clicking","text":"fun ViewInteraction . click (): ViewInteraction = perform ( ViewActions . click ()) Sample: LoginPage (). onSignInOrRegisterButton (). click ()","title":"Clicking"},{"location":"espresso-extensions/#verify-text","text":"fun ViewInteraction . verifyText ( text : String ): ViewInteraction = check ( matches ( withText ( text ))) Sample: LoggedInPage (). onWelcomeGreeting (). verifyText ( \"Welcome Andrew!\" )","title":"Verify Text"},{"location":"espresso-extensions/#androidxtestcore-ktx","text":"androidTestImplementation \"androidx.test:core-ktx:<version>\" Versions Sample: val scenario = launchActivity < LoginActivity > ()","title":"androidx.test:core-ktx"},{"location":"espresso-extensions/#simple-test","text":"Now that all of the page objects are implemented, the last login test can be simplified further using the new extension functions. @Test fun successfulLogin () { val scenario = launchActivity < LoginActivity > () LoginPage (). apply { onEmail (). typeText ( \"andrew@test.com\" ) onPassword (). typeText ( \"password123\" ) onSignInOrRegisterButton (). click () } LoggedInPage (). onWelcomeGreeting (). verifyText ( \"Welcome Andrew!\" ) } The test is starting to look better, however each page has to be instantiated and there is no link between pages when writing tests. Thankfully Kotlin has features that will be covered in the next section to create a navigation DSL.","title":"Simple Test"},{"location":"espresso-extensions/#resources","text":"Source code Github commit 3-espresso-extensions - GitHub Branch","title":"Resources"},{"location":"google-maps/","text":"Automating Google Maps Setup UIAutomator androidTestImplementation \"androidx.test:runner:1.4.0\" androidTestImplementation \"androidx.test:rules:1.4.0\" androidTestImplementation \"androidx.test.uiautomator:uiautomator:2.2.0\" Extension Functions import androidx.test.uiautomator.UiObject import org.junit.Assert.assertTrue fun UiObject . performClick (): UiObject { assertTrue ( \"Clicking UiObject\" , click ()) return this } fun UiObject . verifyVisible ( timeout : Long = 0 ): UiObject { assertTrue ( \"View is Visible\" , waitForExists ( timeout )) return this } Create Map Page Object class MapPage : BasePage () { override fun assertScreen () { } fun onMarker ( title : String ): UiObject { val device = UiDevice . getInstance ( InstrumentationRegistry . getInstrumentation ()) return device . findObject ( UiSelector (). descriptionContains ( title )) } fun onCloseBottomSheetButton (): ViewInteraction = R . id . imageButton . toViewInteraction () fun onMapMarkerBottomSheetText (): ViewInteraction = R . id . map_marker_detail_textview . toViewInteraction () fun onBottomSheet (): ViewInteraction = R . id . standard_bottom_sheet . toViewInteraction () fun verifyBottomSheetState ( expected : Int ) { onBottomSheet (). check ( matches ( hasBottomSheetBehaviorState ( expected ))) } } Bottom Sheet Behavior fun getFriendlyBottomSheetBehaviorStateDescription ( state : Int ): String = when ( state ) { BottomSheetBehavior . STATE_DRAGGING -> \"dragging\" BottomSheetBehavior . STATE_SETTLING -> \"settling\" BottomSheetBehavior . STATE_EXPANDED -> \"expanded\" BottomSheetBehavior . STATE_COLLAPSED -> \"collapsed\" BottomSheetBehavior . STATE_HIDDEN -> \"hidden\" BottomSheetBehavior . STATE_HALF_EXPANDED -> \"half-expanded\" else -> \"unknown but the value was $ state \" } fun hasBottomSheetBehaviorState ( expectedState : Int ): Matcher < in View >? { return object : BoundedMatcher < View , View > ( View :: class . java ) { override fun describeTo ( description : Description ) { description . appendText ( \"has BottomSheetBehavior state: ${ getFriendlyBottomSheetBehaviorStateDescription ( expectedState ) } \" ) } override fun matchesSafely ( view : View ): Boolean { val bottomSheetBehavior = BottomSheetBehavior . from ( view ) return expectedState == bottomSheetBehavior . state } } } fun hasBottomSheetBehaviorState ( expectedState : Int ): Matcher < in View >? { return object : BoundedMatcher < View , View > ( View :: class . java ) { override fun describeTo ( description : Description ) { description . appendText ( \"has BottomSheetBehavior state $ expectedState \" ) } override fun matchesSafely ( view : View ): Boolean { val bottomSheetBehavior = BottomSheetBehavior . from ( view ) return expectedState == bottomSheetBehavior . state } } } private fun setupBottomSheet () { bottomSheetBehavior = BottomSheetBehavior . from ( binding . standardBottomSheet ) bottomSheetBehavior . addBottomSheetCallback ( object : BottomSheetBehavior . BottomSheetCallback () { override fun onStateChanged ( bottomSheet : View , newState : Int ) { Log . d ( \"andrew\" , \"New state: $ newState \" ) if ( newState == BottomSheetBehavior . STATE_SETTLING ) { countingIdlingResource . increment () } else { countingIdlingResource . decrement () } } override fun onSlide ( bottomSheet : View , slideOffset : Float ) { } }) bottomSheetBehavior . isHideable = true bottomSheetBehavior . state = BottomSheetBehavior . STATE_HIDDEN bottomSheetBinding . imageButton . setOnClickListener { bottomSheetBehavior . state = BottomSheetBehavior . STATE_HIDDEN } } Map Test @HiltAndroidTest class MapTest { @get : Rule var hiltRule = HiltAndroidRule ( this ) @get : Rule val composeTestRule = createAndroidComposeRule < MapActivity > () private val _idlingResource = TestCountingIdlingResource () @BindValue @JvmField val idlingResource : CountingIdlingResource = _idlingResource @Before fun setUp () { IdlingRegistry . getInstance (). register ( _idlingResource . instance ) } @After fun tearDown () { IdlingRegistry . getInstance (). unregister ( _idlingResource . instance ) } @Test fun markerIsInViewOnStart () { composeTestRule . startOnPage < MapPage > { onMarker ( MapActivity . SYDNEY_MARKER_TITLE ). verifyVisible () } } @Test fun clickMapMarkerOpensBottomSheet () { composeTestRule . startOnPage < MapPage > { verifyBottomSheetState ( BottomSheetBehavior . STATE_HIDDEN ) onMarker ( MapActivity . SYDNEY_MARKER_TITLE ). performClick () verifyBottomSheetState ( BottomSheetBehavior . STATE_COLLAPSED ) onMapMarkerBottomSheetText (). verifyText ( MapActivity . SYDNEY_MARKER_TITLE ) onCloseBottomSheetButton (). click () verifyBottomSheetState ( BottomSheetBehavior . STATE_HIDDEN ) } } } Resources StackOverflow answer - how to test google maps Source code","title":"Google Maps"},{"location":"google-maps/#automating-google-maps","text":"","title":"Automating Google Maps"},{"location":"google-maps/#setup-uiautomator","text":"androidTestImplementation \"androidx.test:runner:1.4.0\" androidTestImplementation \"androidx.test:rules:1.4.0\" androidTestImplementation \"androidx.test.uiautomator:uiautomator:2.2.0\"","title":"Setup UIAutomator"},{"location":"google-maps/#extension-functions","text":"import androidx.test.uiautomator.UiObject import org.junit.Assert.assertTrue fun UiObject . performClick (): UiObject { assertTrue ( \"Clicking UiObject\" , click ()) return this } fun UiObject . verifyVisible ( timeout : Long = 0 ): UiObject { assertTrue ( \"View is Visible\" , waitForExists ( timeout )) return this }","title":"Extension Functions"},{"location":"google-maps/#create-map-page-object","text":"class MapPage : BasePage () { override fun assertScreen () { } fun onMarker ( title : String ): UiObject { val device = UiDevice . getInstance ( InstrumentationRegistry . getInstrumentation ()) return device . findObject ( UiSelector (). descriptionContains ( title )) } fun onCloseBottomSheetButton (): ViewInteraction = R . id . imageButton . toViewInteraction () fun onMapMarkerBottomSheetText (): ViewInteraction = R . id . map_marker_detail_textview . toViewInteraction () fun onBottomSheet (): ViewInteraction = R . id . standard_bottom_sheet . toViewInteraction () fun verifyBottomSheetState ( expected : Int ) { onBottomSheet (). check ( matches ( hasBottomSheetBehaviorState ( expected ))) } }","title":"Create Map Page Object"},{"location":"google-maps/#bottom-sheet-behavior","text":"fun getFriendlyBottomSheetBehaviorStateDescription ( state : Int ): String = when ( state ) { BottomSheetBehavior . STATE_DRAGGING -> \"dragging\" BottomSheetBehavior . STATE_SETTLING -> \"settling\" BottomSheetBehavior . STATE_EXPANDED -> \"expanded\" BottomSheetBehavior . STATE_COLLAPSED -> \"collapsed\" BottomSheetBehavior . STATE_HIDDEN -> \"hidden\" BottomSheetBehavior . STATE_HALF_EXPANDED -> \"half-expanded\" else -> \"unknown but the value was $ state \" } fun hasBottomSheetBehaviorState ( expectedState : Int ): Matcher < in View >? { return object : BoundedMatcher < View , View > ( View :: class . java ) { override fun describeTo ( description : Description ) { description . appendText ( \"has BottomSheetBehavior state: ${ getFriendlyBottomSheetBehaviorStateDescription ( expectedState ) } \" ) } override fun matchesSafely ( view : View ): Boolean { val bottomSheetBehavior = BottomSheetBehavior . from ( view ) return expectedState == bottomSheetBehavior . state } } } fun hasBottomSheetBehaviorState ( expectedState : Int ): Matcher < in View >? { return object : BoundedMatcher < View , View > ( View :: class . java ) { override fun describeTo ( description : Description ) { description . appendText ( \"has BottomSheetBehavior state $ expectedState \" ) } override fun matchesSafely ( view : View ): Boolean { val bottomSheetBehavior = BottomSheetBehavior . from ( view ) return expectedState == bottomSheetBehavior . state } } } private fun setupBottomSheet () { bottomSheetBehavior = BottomSheetBehavior . from ( binding . standardBottomSheet ) bottomSheetBehavior . addBottomSheetCallback ( object : BottomSheetBehavior . BottomSheetCallback () { override fun onStateChanged ( bottomSheet : View , newState : Int ) { Log . d ( \"andrew\" , \"New state: $ newState \" ) if ( newState == BottomSheetBehavior . STATE_SETTLING ) { countingIdlingResource . increment () } else { countingIdlingResource . decrement () } } override fun onSlide ( bottomSheet : View , slideOffset : Float ) { } }) bottomSheetBehavior . isHideable = true bottomSheetBehavior . state = BottomSheetBehavior . STATE_HIDDEN bottomSheetBinding . imageButton . setOnClickListener { bottomSheetBehavior . state = BottomSheetBehavior . STATE_HIDDEN } }","title":"Bottom Sheet Behavior"},{"location":"google-maps/#map-test","text":"@HiltAndroidTest class MapTest { @get : Rule var hiltRule = HiltAndroidRule ( this ) @get : Rule val composeTestRule = createAndroidComposeRule < MapActivity > () private val _idlingResource = TestCountingIdlingResource () @BindValue @JvmField val idlingResource : CountingIdlingResource = _idlingResource @Before fun setUp () { IdlingRegistry . getInstance (). register ( _idlingResource . instance ) } @After fun tearDown () { IdlingRegistry . getInstance (). unregister ( _idlingResource . instance ) } @Test fun markerIsInViewOnStart () { composeTestRule . startOnPage < MapPage > { onMarker ( MapActivity . SYDNEY_MARKER_TITLE ). verifyVisible () } } @Test fun clickMapMarkerOpensBottomSheet () { composeTestRule . startOnPage < MapPage > { verifyBottomSheetState ( BottomSheetBehavior . STATE_HIDDEN ) onMarker ( MapActivity . SYDNEY_MARKER_TITLE ). performClick () verifyBottomSheetState ( BottomSheetBehavior . STATE_COLLAPSED ) onMapMarkerBottomSheetText (). verifyText ( MapActivity . SYDNEY_MARKER_TITLE ) onCloseBottomSheetButton (). click () verifyBottomSheetState ( BottomSheetBehavior . STATE_HIDDEN ) } } }","title":"Map Test"},{"location":"google-maps/#resources","text":"StackOverflow answer - how to test google maps Source code","title":"Resources"},{"location":"integrate-with-api/","text":"Integrate With API \ud83d\udea7 TODO \ud83d\udea7 Resources Source Code 7-integrate-api branch Github commit Ktor Start ktor project website","title":"Integrate With API"},{"location":"integrate-with-api/#integrate-with-api","text":"\ud83d\udea7 TODO \ud83d\udea7","title":"Integrate With API"},{"location":"integrate-with-api/#resources","text":"Source Code 7-integrate-api branch Github commit Ktor Start ktor project website","title":"Resources"},{"location":"jetpack-compose/","text":"Update the Navigation Function inline fun < reified T : BasePage > BasePage . navigateToPageWithClick ( semanticsNodeInteraction : SemanticsNodeInteraction , block : PageScope < T > ): T { semanticsNodeInteraction . performClick () return T :: class . java . newInstance (). apply { this . composeTestRule = this @navigateToPageWithClick.composeTestRule assertScreen () block () } } inline fun < reified T : BasePage > ComposeTestRule . startOnPage ( block : PageScope < T > = {}): T = T :: class . java . newInstance (). apply { this . composeTestRule = this @startOnPage assertScreen () block () } Convert BasePage to Abstract Class abstract class BasePage { lateinit var composeTestRule : ComposeTestRule abstract fun assertScreen () fun Int . toViewInteraction (): ViewInteraction = onView ( withId ( this )) } Update Pages class LoginPage : BasePage () { override fun assertScreen () { onSignInOrRegisterButton (). assertIsDisplayed () } fun onSignInOrRegisterButton (): SemanticsNodeInteraction { val text = InstrumentationRegistry . getInstrumentation (). targetContext . getString ( R . string . action_sign_in ) return composeTestRule . onNodeWithText ( text = text ) } fun goToLoggedInPage ( block : PageScope < LoggedInPage > ): LoggedInPage = navigateToPageWithClick ( onSignInOrRegisterButton (), block ) } Since the navigateToPageWithClick has the same name as the other version which takes a ViewInteraction , it technically doesn't need to be updated! Update Test class MockkLoginTest { @get : Rule val composeTestRule = createAndroidComposeRule < LoginActivity > () @Test fun successfulLogin () { // omitted code //use extension function on ComposeTestRule to start the navigation composeTestRule . startOnPage < LoginPage > { enterInfo ( \"andrew@example.com\" , \"password\" ) }. goToLoggedInPage { onWelcomeGreeting (). verifyText ( \"Welcome Andrew!\" ) }. goToSettings () } } Replace View With Compose <androidx.compose.ui.platform.ComposeView android:id= \"@+id/login_button\" ... /> binding . loginButton . setContent { val state = loginViewModel . loginFormState . observeAsState () Button ( onClick = { loading . visibility = View . VISIBLE loginViewModel . login ( username . text . toString (), password . text . toString ()) }, enabled = state . value ?. isDataValid ?: false ) { Text ( text = stringResource ( id = R . string . action_sign_in )) } } Resources Github commit of source code Jetpack compose reactive stream dependencies Compose Testing Documentation Adding Jetpack Compose to existing project documentation","title":"Jetpack Compose"},{"location":"jetpack-compose/#update-the-navigation-function","text":"inline fun < reified T : BasePage > BasePage . navigateToPageWithClick ( semanticsNodeInteraction : SemanticsNodeInteraction , block : PageScope < T > ): T { semanticsNodeInteraction . performClick () return T :: class . java . newInstance (). apply { this . composeTestRule = this @navigateToPageWithClick.composeTestRule assertScreen () block () } } inline fun < reified T : BasePage > ComposeTestRule . startOnPage ( block : PageScope < T > = {}): T = T :: class . java . newInstance (). apply { this . composeTestRule = this @startOnPage assertScreen () block () }","title":"Update the Navigation Function"},{"location":"jetpack-compose/#convert-basepage-to-abstract-class","text":"abstract class BasePage { lateinit var composeTestRule : ComposeTestRule abstract fun assertScreen () fun Int . toViewInteraction (): ViewInteraction = onView ( withId ( this )) }","title":"Convert BasePage to Abstract Class"},{"location":"jetpack-compose/#update-pages","text":"class LoginPage : BasePage () { override fun assertScreen () { onSignInOrRegisterButton (). assertIsDisplayed () } fun onSignInOrRegisterButton (): SemanticsNodeInteraction { val text = InstrumentationRegistry . getInstrumentation (). targetContext . getString ( R . string . action_sign_in ) return composeTestRule . onNodeWithText ( text = text ) } fun goToLoggedInPage ( block : PageScope < LoggedInPage > ): LoggedInPage = navigateToPageWithClick ( onSignInOrRegisterButton (), block ) } Since the navigateToPageWithClick has the same name as the other version which takes a ViewInteraction , it technically doesn't need to be updated!","title":"Update Pages"},{"location":"jetpack-compose/#update-test","text":"class MockkLoginTest { @get : Rule val composeTestRule = createAndroidComposeRule < LoginActivity > () @Test fun successfulLogin () { // omitted code //use extension function on ComposeTestRule to start the navigation composeTestRule . startOnPage < LoginPage > { enterInfo ( \"andrew@example.com\" , \"password\" ) }. goToLoggedInPage { onWelcomeGreeting (). verifyText ( \"Welcome Andrew!\" ) }. goToSettings () } }","title":"Update Test"},{"location":"jetpack-compose/#replace-view-with-compose","text":"<androidx.compose.ui.platform.ComposeView android:id= \"@+id/login_button\" ... /> binding . loginButton . setContent { val state = loginViewModel . loginFormState . observeAsState () Button ( onClick = { loading . visibility = View . VISIBLE loginViewModel . login ( username . text . toString (), password . text . toString ()) }, enabled = state . value ?. isDataValid ?: false ) { Text ( text = stringResource ( id = R . string . action_sign_in )) } }","title":"Replace View With Compose"},{"location":"jetpack-compose/#resources","text":"Github commit of source code Jetpack compose reactive stream dependencies Compose Testing Documentation Adding Jetpack Compose to existing project documentation","title":"Resources"},{"location":"mock-ktor-test/","text":"Mock Ktor Testing One of the most popular frameworks used for networking on Android most notably would be Retrofit and is a great library to use with a simple API. Although when it comes to writing a mock network test in Espresso, the solution to mock the network traffic is running a MockWebServer or any other JVM server of your choice. Instead of running a separate server, what if the networking library used could swap out the underlying engine executing the Http calls with a mock engine? That is exactly what Ktor from Jetbrains can do with the MockEngine and will be used to write a mock network Espresso test. Architecture Working with the previous architecture, a Ktor HttpClient will be injected into the LoginDataSource except the test will inject the MockEngine . Adding Ktor and KotlinxSerialization // build.gradle buildscript { ext . kotlin_version = \"1.6.0\" ext . ktor_version = \"1.6.7\" dependencies { classpath \"org.jetbrains.kotlin:kotlin-serialization:$kotlin_version\" } } // app/build.gradle plugins { id 'org.jetbrains.kotlin.plugin.serialization' } dependencies { // Ktor implementation \"io.ktor:ktor-client-android:$ktor_version\" implementation \"io.ktor:ktor-client-serialization-jvm:$ktor_version\" implementation \"io.ktor:ktor-client-json:$ktor_version\" androidTestImplementation \"io.ktor:ktor-client-mock:$ktor_version\" // Kotlinx Serialization - JSON implementation \"org.jetbrains.kotlinx:kotlinx-serialization-json:1.3.0\" } Create an Http Client @Module @InstallIn ( SingletonComponent :: class ) object HttpEngineModule { @Provides @Singleton fun providesHttpEngine (): HttpClientEngine = Android . create () } @Module @InstallIn ( SingletonComponent :: class ) object HttpClientModule { @Provides @Singleton fun providesHttpClient ( httpClientEngine : HttpClientEngine ): HttpClient = HttpClient ( httpClientEngine ) { install ( JsonFeature ) { serializer = KotlinxSerializer () } } } Implement the API Call @Serializable data class LoginRequest ( val username : String , val password : String ) @Serializable data class LoginResponse ( val id : String , val displayName : String ) @Serializable data class LoginError ( val errorCode : Int , val message : String ) class LoginDataSource @Inject constructor ( private val httpClient : HttpClient ) { companion object { const val LOGIN_URL = \"https://plusmobileapps.com/login\" } suspend fun login ( email : String , password : String ): Result < LoggedInUser > = withContext ( Dispatchers . IO ) { try { val response = httpClient . post < LoginResponse > ( LOGIN_URL ) { contentType ( ContentType . Application . Json ) body = LoginRequest ( email , password ) } val user = LoggedInUser ( response . id , response . displayName ) Result . Success ( user ) } catch ( e : Throwable ) { val errorMessage = if ( e is ClientRequestException ) { val response = e . response . readText ( Charsets . UTF_8 ) val error = Json . decodeFromString < LoginError > ( response ) error . message } else { \"Don't know the error\" } Result . Error ( IOException ( errorMessage , e )) } } } Write a MockNetworkHelper In order to keep the tests a tidy, it would help to write a MockNetworkHelper to abstract away and consolidate the logic for responding to specific endpoints. class MockNetworkTestHelper { val httpClientEngine : HttpClientEngine = MockEngine { request -> when ( request . url . fullUrl ) { LoginDataSource . LOGIN_URL -> getLoginResponse . invoke ( this , request ) else -> error ( \"Unhandled ${ request . url . fullUrl } \" ) } } private var getLoginResponse : MockRequestHandler = defaultLoginResponseHandler fun everyLoginReturns ( response : MockRequestHandler ) { this . getLoginResponse = response } fun destroy () { getLoginResponse = defaultLoginResponseHandler } companion object { val defaultLoginResponseHandler : MockRequestHandler = { respond ( Json . encodeToString ( LoginResponse ( \"default-id\" , \"Buzz Killington\" )), HttpStatusCode . OK , headersOf ( HttpHeaders . ContentType , ContentType . Application . Json . toString ()) ) } } } val Url . hostWithPortIfRequired : String get () = if ( port == protocol . defaultPort ) host else hostWithPort val Url . fullUrl : String get () = \" ${ protocol . name } :// $ hostWithPortIfRequired $ fullPath \" Write the test @UninstallModules ( HttpEngineModule :: class ) @HiltAndroidTest class MockNetworkLoginTest { @get : Rule var hiltRule = HiltAndroidRule ( this ) private val networkHelper = MockNetworkTestHelper () @BindValue @JvmField val mockClient : HttpClientEngine = networkHelper . httpClientEngine private val username = \"andrew\" private val password = \"password123\" private val displayName = \"Buzz Killington\" @After fun tearDown () { networkHelper . destroy () } @Test fun successfulLogin () { networkHelper . everyLoginReturns { respond ( Json . encodeToString ( LoginResponse ( \"first-id\" , displayName )), HttpStatusCode . OK , headersOf ( HttpHeaders . ContentType , ContentType . Application . Json . toString ()) ) } val activityScenario = launchActivity < LoginActivity > () startOnPage < LoginPage > { enterInfo ( username , password ) }. goToLoggedInPage { onWelcomeGreeting (). verifyText ( \"Welcome $ displayName !\" ) }. goToSettings () activityScenario . close () } @Test fun errorLogin () { val expectedError = LoginError ( 1 , \"There was an error\" ) networkHelper . everyLoginReturns { respond ( Json . encodeToString ( LoginError . serializer (), expectedError ), HttpStatusCode . BadRequest ) } val activityScenario = launchActivity < LoginActivity > () startOnPage < LoginPage > { enterInfo ( username , password ) onSignInOrRegisterButton (). click () onErrorMessage (). verifyText ( expectedError . message ). verifyVisible () } activityScenario . close () } } Counting Idling Resource @HiltViewModel class LoginViewModel @Inject constructor ( private val loginRepository : LoginRepository , private val idlingResource : CountingIdlingResource ) : ViewModel () { fun login ( email : String , password : String ) { idlingResource . increment () viewModelScope . launch { // delay is just for local development to ensure espresso waits for job to finish delay ( 2 _000 ) // can be launched in a separate asynchronous job val result = loginRepository . login ( email , password ) when ( result ) { is Result . Error -> LoginResult ( errorString = result . exception . message ) is Result . Success -> LoginResult ( success = LoggedInUserView ( displayName = result . data . displayName )) }. let { _loginResult . value = it } idlingResource . decrement () } } } Resources Add ktor, kotlinx.serialization, and mock network test commit Add CI/CD workflow commit Add counting idling resource to fix flaky test commit 6-mock-ktor-network-test branch Coroutine idling resource workaround and commit","title":"Mock Ktor Test"},{"location":"mock-ktor-test/#mock-ktor-testing","text":"One of the most popular frameworks used for networking on Android most notably would be Retrofit and is a great library to use with a simple API. Although when it comes to writing a mock network test in Espresso, the solution to mock the network traffic is running a MockWebServer or any other JVM server of your choice. Instead of running a separate server, what if the networking library used could swap out the underlying engine executing the Http calls with a mock engine? That is exactly what Ktor from Jetbrains can do with the MockEngine and will be used to write a mock network Espresso test.","title":"Mock Ktor Testing"},{"location":"mock-ktor-test/#architecture","text":"Working with the previous architecture, a Ktor HttpClient will be injected into the LoginDataSource except the test will inject the MockEngine .","title":"Architecture"},{"location":"mock-ktor-test/#adding-ktor-and-kotlinxserialization","text":"// build.gradle buildscript { ext . kotlin_version = \"1.6.0\" ext . ktor_version = \"1.6.7\" dependencies { classpath \"org.jetbrains.kotlin:kotlin-serialization:$kotlin_version\" } } // app/build.gradle plugins { id 'org.jetbrains.kotlin.plugin.serialization' } dependencies { // Ktor implementation \"io.ktor:ktor-client-android:$ktor_version\" implementation \"io.ktor:ktor-client-serialization-jvm:$ktor_version\" implementation \"io.ktor:ktor-client-json:$ktor_version\" androidTestImplementation \"io.ktor:ktor-client-mock:$ktor_version\" // Kotlinx Serialization - JSON implementation \"org.jetbrains.kotlinx:kotlinx-serialization-json:1.3.0\" }","title":"Adding Ktor and KotlinxSerialization"},{"location":"mock-ktor-test/#create-an-http-client","text":"@Module @InstallIn ( SingletonComponent :: class ) object HttpEngineModule { @Provides @Singleton fun providesHttpEngine (): HttpClientEngine = Android . create () } @Module @InstallIn ( SingletonComponent :: class ) object HttpClientModule { @Provides @Singleton fun providesHttpClient ( httpClientEngine : HttpClientEngine ): HttpClient = HttpClient ( httpClientEngine ) { install ( JsonFeature ) { serializer = KotlinxSerializer () } } }","title":"Create an Http Client"},{"location":"mock-ktor-test/#implement-the-api-call","text":"@Serializable data class LoginRequest ( val username : String , val password : String ) @Serializable data class LoginResponse ( val id : String , val displayName : String ) @Serializable data class LoginError ( val errorCode : Int , val message : String ) class LoginDataSource @Inject constructor ( private val httpClient : HttpClient ) { companion object { const val LOGIN_URL = \"https://plusmobileapps.com/login\" } suspend fun login ( email : String , password : String ): Result < LoggedInUser > = withContext ( Dispatchers . IO ) { try { val response = httpClient . post < LoginResponse > ( LOGIN_URL ) { contentType ( ContentType . Application . Json ) body = LoginRequest ( email , password ) } val user = LoggedInUser ( response . id , response . displayName ) Result . Success ( user ) } catch ( e : Throwable ) { val errorMessage = if ( e is ClientRequestException ) { val response = e . response . readText ( Charsets . UTF_8 ) val error = Json . decodeFromString < LoginError > ( response ) error . message } else { \"Don't know the error\" } Result . Error ( IOException ( errorMessage , e )) } } }","title":"Implement the API Call"},{"location":"mock-ktor-test/#write-a-mocknetworkhelper","text":"In order to keep the tests a tidy, it would help to write a MockNetworkHelper to abstract away and consolidate the logic for responding to specific endpoints. class MockNetworkTestHelper { val httpClientEngine : HttpClientEngine = MockEngine { request -> when ( request . url . fullUrl ) { LoginDataSource . LOGIN_URL -> getLoginResponse . invoke ( this , request ) else -> error ( \"Unhandled ${ request . url . fullUrl } \" ) } } private var getLoginResponse : MockRequestHandler = defaultLoginResponseHandler fun everyLoginReturns ( response : MockRequestHandler ) { this . getLoginResponse = response } fun destroy () { getLoginResponse = defaultLoginResponseHandler } companion object { val defaultLoginResponseHandler : MockRequestHandler = { respond ( Json . encodeToString ( LoginResponse ( \"default-id\" , \"Buzz Killington\" )), HttpStatusCode . OK , headersOf ( HttpHeaders . ContentType , ContentType . Application . Json . toString ()) ) } } } val Url . hostWithPortIfRequired : String get () = if ( port == protocol . defaultPort ) host else hostWithPort val Url . fullUrl : String get () = \" ${ protocol . name } :// $ hostWithPortIfRequired $ fullPath \"","title":"Write a MockNetworkHelper"},{"location":"mock-ktor-test/#write-the-test","text":"@UninstallModules ( HttpEngineModule :: class ) @HiltAndroidTest class MockNetworkLoginTest { @get : Rule var hiltRule = HiltAndroidRule ( this ) private val networkHelper = MockNetworkTestHelper () @BindValue @JvmField val mockClient : HttpClientEngine = networkHelper . httpClientEngine private val username = \"andrew\" private val password = \"password123\" private val displayName = \"Buzz Killington\" @After fun tearDown () { networkHelper . destroy () } @Test fun successfulLogin () { networkHelper . everyLoginReturns { respond ( Json . encodeToString ( LoginResponse ( \"first-id\" , displayName )), HttpStatusCode . OK , headersOf ( HttpHeaders . ContentType , ContentType . Application . Json . toString ()) ) } val activityScenario = launchActivity < LoginActivity > () startOnPage < LoginPage > { enterInfo ( username , password ) }. goToLoggedInPage { onWelcomeGreeting (). verifyText ( \"Welcome $ displayName !\" ) }. goToSettings () activityScenario . close () } @Test fun errorLogin () { val expectedError = LoginError ( 1 , \"There was an error\" ) networkHelper . everyLoginReturns { respond ( Json . encodeToString ( LoginError . serializer (), expectedError ), HttpStatusCode . BadRequest ) } val activityScenario = launchActivity < LoginActivity > () startOnPage < LoginPage > { enterInfo ( username , password ) onSignInOrRegisterButton (). click () onErrorMessage (). verifyText ( expectedError . message ). verifyVisible () } activityScenario . close () } }","title":"Write the test"},{"location":"mock-ktor-test/#counting-idling-resource","text":"@HiltViewModel class LoginViewModel @Inject constructor ( private val loginRepository : LoginRepository , private val idlingResource : CountingIdlingResource ) : ViewModel () { fun login ( email : String , password : String ) { idlingResource . increment () viewModelScope . launch { // delay is just for local development to ensure espresso waits for job to finish delay ( 2 _000 ) // can be launched in a separate asynchronous job val result = loginRepository . login ( email , password ) when ( result ) { is Result . Error -> LoginResult ( errorString = result . exception . message ) is Result . Success -> LoginResult ( success = LoggedInUserView ( displayName = result . data . displayName )) }. let { _loginResult . value = it } idlingResource . decrement () } } }","title":"Counting Idling Resource"},{"location":"mock-ktor-test/#resources","text":"Add ktor, kotlinx.serialization, and mock network test commit Add CI/CD workflow commit Add counting idling resource to fix flaky test commit 6-mock-ktor-network-test branch Coroutine idling resource workaround and commit","title":"Resources"},{"location":"mockk-test/","text":"Mockk Test The first strategy to discuss when it comes to mock testing in Android is replacing a dependency in the app with a mock using Mockk . With this approach, it helps to look at a diagram of the app architecture to better understand what is actually being tested and what can be controlled with a mock. To try to maximize the test coverage of the app and control the source of data, the LoginDataSource is what will be replaced with a mock to ensure consistent test data. Note One could just as easily replace the LoginRepository or the LoginViewModel with a mock in a test, however consider what the test itself is actually testing when replacing layers of the architecture at a higher level. This sort of approach might be more feasible if there is confidence in the unit test coverage in the repository or ViewModel, although mocking the network source is usually the best approach to test the integration of every layer in an app. MockK Test Setup To setup the project for a Mockk test, a dependency injection framework such as Hilt will be helpful to easily swap out dependencies in the app with mocks. Since the purpose of this tutorial is not to deep dive into Hilt or Mockk, the setup of Hilt can be found in this commit and Mockk simply requires this one line in the app build.gradle . androidTestImplementation \"io.mockk:mockk-android:1.12.0\" Write a Login Error Test To start writing a Hilt Espresso test, we need to add the @HiltAndroidTest annotation to the test class and declare a Hilt rule. @HiltAndroidTest class MockkLoginTest { @get : Rule var hiltRule = HiltAndroidRule ( this ) } Now to override the LoginDataSource with a mockk, we can declare a mock as a property and annotate with the @JvmField and @BindValue to override the mock in the dependency graph. @BindValue @JvmField val loginDataSource : LoginDataSource = mockk ( relaxed = true ) Finally in a test, the data source can be mocked out with an error response and validates the user is shown the error. @Test fun errorLogin () { val expectedError = \"Something bad happened\" every { loginDataSource . login ( email , password ) } returns Result . Error ( IllegalArgumentException ( expectedError )) val scenario = launchActivity < LoginActivity > () startOnPage < LoginPage > { enterInfo ( email , password ); onSignInOrRegisterButton (). click () onErrorMessage (). verifyText ( expectedError ). verifyVisible () } scenario . close () } This is pretty much the basis for writing an Espresso mock test with Mockk. So if you were to update the successful login test, how would you rewrite the other login test to return something dynamic? enter info on the login page and submit verify the welcome greeting display name verify navigation to the settings Answer @Test fun successfulLogin () { every { loginDataSource . login ( email , password ) } returns Result . Success ( LoggedInUser ( \"some-user-id\" , displayName )) val scenario = launchActivity < LoginActivity > () startOnPage < LoginPage > { enterInfo ( email , password ) }. goToLoggedInPage { onWelcomeGreeting (). verifyText ( \"Welcome $ displayName !\" ) }. goToSettings () scenario . close () } Add mockk and mock tests commit - contains all the code for tests added in this section Pre Android Pie (API 28) mocking Up until this point the app will run fine on Android P and above, however there are some limitations to Mockk mocking final classes in Espresso before that. Running the test on an emulator lower than API 28 will result in the following error caused by the mocking call. If you are writing an Android app that has a minimum SDK less than Android P and need to mock a final class in a test. The recommended approach on the Mockk Android page is to use Dexopener , however if you look on the project readme you will see: Quote DexOpener will do the following things at runtime: Remove the final modifier from the classes belonging to the specified package Create dex files to make the application class loader load those classes However, they are not so lightweight. If you would like to save even a little testing time of your Kotlin app, you can introduce the all-open compiler plugin instead of DexOpener. So to keep the mock tests as performant as possible we will use the Kotlin all open compiler which will only open up classes marked with an annotation on debug builds. The first thing to use the all open compiler is to create an annotation class which can then be used to mark classes desired to be opened for testing. package com.plusmobileapps.kotlinopenespresso annotation class OpenForTest Now that there is an annotation class to mark tests for open, the open compiler dependencies need to be added to the project and instructed which annotation should be used to know which classes to open. // root build.gradle buildscript { dependencies { classpath \"org.jetbrains.kotlin:kotlin-allopen:$kotlin_version\" } } // app build.gradle allOpen { annotation ( \"com.plusmobileapps.kotlinopenespresso.OpenForTest\" ) } At last mark the final class needing to be mocked with the new annotation and the test should now run on pre Android P devices! @OpenForTest class LoginDataSource @Inject constructor () {} Add Kotlin all open compiler commit Warning Mockk tests are a good start for writing some mock Espresso tests, however this approach does completely swap out the implementation detail of LoginDataSource . If you looked more closely at all the changes, you might have noticed that the implementation of LoginDataSource is actually still returning a hardcoded display name. This was intentional to showcase that this approach does have some short comings because the test passes however in production it is not yet quite dynamic. The next section will explain another approach to mock testing that will simply mock the network traffic in the test to fully test the integration of everything in the app. Source 5-mockk-test branch","title":"Mockk Test"},{"location":"mockk-test/#mockk-test","text":"The first strategy to discuss when it comes to mock testing in Android is replacing a dependency in the app with a mock using Mockk . With this approach, it helps to look at a diagram of the app architecture to better understand what is actually being tested and what can be controlled with a mock. To try to maximize the test coverage of the app and control the source of data, the LoginDataSource is what will be replaced with a mock to ensure consistent test data. Note One could just as easily replace the LoginRepository or the LoginViewModel with a mock in a test, however consider what the test itself is actually testing when replacing layers of the architecture at a higher level. This sort of approach might be more feasible if there is confidence in the unit test coverage in the repository or ViewModel, although mocking the network source is usually the best approach to test the integration of every layer in an app.","title":"Mockk Test"},{"location":"mockk-test/#mockk-test-setup","text":"To setup the project for a Mockk test, a dependency injection framework such as Hilt will be helpful to easily swap out dependencies in the app with mocks. Since the purpose of this tutorial is not to deep dive into Hilt or Mockk, the setup of Hilt can be found in this commit and Mockk simply requires this one line in the app build.gradle . androidTestImplementation \"io.mockk:mockk-android:1.12.0\"","title":"MockK Test Setup"},{"location":"mockk-test/#write-a-login-error-test","text":"To start writing a Hilt Espresso test, we need to add the @HiltAndroidTest annotation to the test class and declare a Hilt rule. @HiltAndroidTest class MockkLoginTest { @get : Rule var hiltRule = HiltAndroidRule ( this ) } Now to override the LoginDataSource with a mockk, we can declare a mock as a property and annotate with the @JvmField and @BindValue to override the mock in the dependency graph. @BindValue @JvmField val loginDataSource : LoginDataSource = mockk ( relaxed = true ) Finally in a test, the data source can be mocked out with an error response and validates the user is shown the error. @Test fun errorLogin () { val expectedError = \"Something bad happened\" every { loginDataSource . login ( email , password ) } returns Result . Error ( IllegalArgumentException ( expectedError )) val scenario = launchActivity < LoginActivity > () startOnPage < LoginPage > { enterInfo ( email , password ); onSignInOrRegisterButton (). click () onErrorMessage (). verifyText ( expectedError ). verifyVisible () } scenario . close () } This is pretty much the basis for writing an Espresso mock test with Mockk. So if you were to update the successful login test, how would you rewrite the other login test to return something dynamic? enter info on the login page and submit verify the welcome greeting display name verify navigation to the settings Answer @Test fun successfulLogin () { every { loginDataSource . login ( email , password ) } returns Result . Success ( LoggedInUser ( \"some-user-id\" , displayName )) val scenario = launchActivity < LoginActivity > () startOnPage < LoginPage > { enterInfo ( email , password ) }. goToLoggedInPage { onWelcomeGreeting (). verifyText ( \"Welcome $ displayName !\" ) }. goToSettings () scenario . close () } Add mockk and mock tests commit - contains all the code for tests added in this section","title":"Write a Login Error Test"},{"location":"mockk-test/#pre-android-pie-api-28-mocking","text":"Up until this point the app will run fine on Android P and above, however there are some limitations to Mockk mocking final classes in Espresso before that. Running the test on an emulator lower than API 28 will result in the following error caused by the mocking call. If you are writing an Android app that has a minimum SDK less than Android P and need to mock a final class in a test. The recommended approach on the Mockk Android page is to use Dexopener , however if you look on the project readme you will see: Quote DexOpener will do the following things at runtime: Remove the final modifier from the classes belonging to the specified package Create dex files to make the application class loader load those classes However, they are not so lightweight. If you would like to save even a little testing time of your Kotlin app, you can introduce the all-open compiler plugin instead of DexOpener. So to keep the mock tests as performant as possible we will use the Kotlin all open compiler which will only open up classes marked with an annotation on debug builds. The first thing to use the all open compiler is to create an annotation class which can then be used to mark classes desired to be opened for testing. package com.plusmobileapps.kotlinopenespresso annotation class OpenForTest Now that there is an annotation class to mark tests for open, the open compiler dependencies need to be added to the project and instructed which annotation should be used to know which classes to open. // root build.gradle buildscript { dependencies { classpath \"org.jetbrains.kotlin:kotlin-allopen:$kotlin_version\" } } // app build.gradle allOpen { annotation ( \"com.plusmobileapps.kotlinopenespresso.OpenForTest\" ) } At last mark the final class needing to be mocked with the new annotation and the test should now run on pre Android P devices! @OpenForTest class LoginDataSource @Inject constructor () {} Add Kotlin all open compiler commit Warning Mockk tests are a good start for writing some mock Espresso tests, however this approach does completely swap out the implementation detail of LoginDataSource . If you looked more closely at all the changes, you might have noticed that the implementation of LoginDataSource is actually still returning a hardcoded display name. This was intentional to showcase that this approach does have some short comings because the test passes however in production it is not yet quite dynamic. The next section will explain another approach to mock testing that will simply mock the network traffic in the test to fully test the integration of everything in the app.","title":"Pre Android Pie (API 28) mocking"},{"location":"mockk-test/#source","text":"5-mockk-test branch","title":"Source"},{"location":"navigation-dsl/","text":"Navigation DSL Writing Espresso tests with the page objects so far has helped in code readability and maintainability. To help accelerate writing the tests in the app, a navigation domain specific language (DSL) can be made to help navigate and make assertions on the current screen in a test. Info To build the navigation DSL, it will help to have a basic understanding of higher order functions and function literals with receiver to better understand how the type safe builders in the DSL are being made. Simple DSL Considering the two pages in the app, the first method to navigate would be from the LoginPage to the LoggedInPage . LoginPage LoggedInPage The simplest way to implement a navigation method on a page object would be to make use of some .apply { } blocks. class LoginPage : BasePage { fun goToLoggedInPage ( block : LoggedInPage .() -> Unit ): LoggedInPage { onSignInOrRegisterButton (). click () return LoggedInPage (). apply { assertScreen () block () } } } Then a simple test could look like this: @Test fun successfulLogin () { LoginPage (). apply { assertScreen () enterInfo ( username , password ) }. goToLoggedInPage { onBodyText (). verifyText ( \"Welcome Andrew!\" ) } } This simple test is a good start in the DSL, however there are a few areas of improvement. every navigation function parameter will have duplication to declare the function literal with a receiver on the navigated to page object the navigation function is verbose to always click a button, assert the screen was navigated to, then apply the lambda to its receiver the first screen in the test will always be asserting the screen and a lambda with a receiver on that page PageScope To simplify the function parameter of a navigation function and reduce the need to always declare it as a lambda with a receiver. Creating a type alias with a generic can help simplify the function parameter declaration. typealias PageScope < T > = T .() -> Unit Now the navigation function can be declared with the following syntax. class LoginPage : BasePage { fun goToLoggedInPage ( block : PageScope < LoginPage > ): LoggedInPage {} } Navigate click helper Most navigation methods typically happen in the following order. some click on the screen instantiate the page object being navigated to assert screen navigated to is showing apply the PageScope to the page so any interaction from the test can occur To help make writing a click navigation function easier, an extension function on BasePage that takes the view being clicked on and the PageScope as a parameter. inline fun < reified T : BasePage > BasePage . navigateToPageWithClick ( viewInteraction : ViewInteraction , block : PageScope < T > ): T { viewInteraction . click () // 1 return T :: class . java . newInstance (). apply { // 2 assertScreen () // 3 block () // 4 } } Now the navigation method can be simplified to the following: class LoginPage : BasePage { fun goToLoggedInPage ( block : PageScope < LoggedInPage > ): LoggedInPage = navigateToPageWithClick ( onSignInOrRegisterButton (), block ) } Start navigation The start of every test instantiates a new page object and asserts that the screen was show before applying the PageScope . To simplify this task, some logic from the click helper function can be reused. inline fun < reified T : BasePage > startOnPage ( block : PageScope < T > = {}): T = T :: class . java . newInstance (). apply { assertScreen () block () } Navigate without interaction It may be possible that a test will need to navigate to a screen but not interact with that page. So it would be desired to continue navigation without needing to supply another lambda which is simple by using a default argument as an empty lambda in the navigation function. class LoggedInPage : BasePage { fun goToSettings ( block : PageScope < Settings > = {}): SettingsPage = navigateToWithClick ( onSettings (), block ) } DSL Structure Putting everything together, the basic of the structure of the navigation DSL would have a test looking like the following: @Test fun successfulLogin () { startOnPage < LoginPage > { // start navigation // this: LoginPage // interact with screen enterInfo ( username , password ) }. goToLoggedInPage { // chained methods navigate to another screen // this: LoggedInPage // or make assertions onBodyText (). verifyText ( \"Welcome Andrew!\" ) }. goToSettings () // default empty scoped lambda can assert navigation to a screen but not interact } Navigation is done with startOnPage() or a function in a page object, which should provides a scoped lambda to the page Each navigation function also returns the page being navigated to in order to chain navigation methods after scoped lambdas View interactions and assertions occur inside of each scoped lambda with the page as its receiver Any PageScope function parameter should provide a default empty lambda so navigation can be asserted, but not require interaction with a screen. The test is starting to look a lot cleaner utilizing the page object pattern, extension functions, and creating a navigation DSL. However the production code is hard coded to get the test to pass and in the next couple sections we will learn about a couple different approaches in making mock tests with more dynamic production looking code. References Source code Github commit 4-navigation-dsl - GitHub branch","title":"Navigation DSL"},{"location":"navigation-dsl/#navigation-dsl","text":"Writing Espresso tests with the page objects so far has helped in code readability and maintainability. To help accelerate writing the tests in the app, a navigation domain specific language (DSL) can be made to help navigate and make assertions on the current screen in a test. Info To build the navigation DSL, it will help to have a basic understanding of higher order functions and function literals with receiver to better understand how the type safe builders in the DSL are being made.","title":"Navigation DSL"},{"location":"navigation-dsl/#simple-dsl","text":"Considering the two pages in the app, the first method to navigate would be from the LoginPage to the LoggedInPage . LoginPage LoggedInPage The simplest way to implement a navigation method on a page object would be to make use of some .apply { } blocks. class LoginPage : BasePage { fun goToLoggedInPage ( block : LoggedInPage .() -> Unit ): LoggedInPage { onSignInOrRegisterButton (). click () return LoggedInPage (). apply { assertScreen () block () } } } Then a simple test could look like this: @Test fun successfulLogin () { LoginPage (). apply { assertScreen () enterInfo ( username , password ) }. goToLoggedInPage { onBodyText (). verifyText ( \"Welcome Andrew!\" ) } } This simple test is a good start in the DSL, however there are a few areas of improvement. every navigation function parameter will have duplication to declare the function literal with a receiver on the navigated to page object the navigation function is verbose to always click a button, assert the screen was navigated to, then apply the lambda to its receiver the first screen in the test will always be asserting the screen and a lambda with a receiver on that page","title":"Simple DSL"},{"location":"navigation-dsl/#pagescope","text":"To simplify the function parameter of a navigation function and reduce the need to always declare it as a lambda with a receiver. Creating a type alias with a generic can help simplify the function parameter declaration. typealias PageScope < T > = T .() -> Unit Now the navigation function can be declared with the following syntax. class LoginPage : BasePage { fun goToLoggedInPage ( block : PageScope < LoginPage > ): LoggedInPage {} }","title":"PageScope"},{"location":"navigation-dsl/#navigate-click-helper","text":"Most navigation methods typically happen in the following order. some click on the screen instantiate the page object being navigated to assert screen navigated to is showing apply the PageScope to the page so any interaction from the test can occur To help make writing a click navigation function easier, an extension function on BasePage that takes the view being clicked on and the PageScope as a parameter. inline fun < reified T : BasePage > BasePage . navigateToPageWithClick ( viewInteraction : ViewInteraction , block : PageScope < T > ): T { viewInteraction . click () // 1 return T :: class . java . newInstance (). apply { // 2 assertScreen () // 3 block () // 4 } } Now the navigation method can be simplified to the following: class LoginPage : BasePage { fun goToLoggedInPage ( block : PageScope < LoggedInPage > ): LoggedInPage = navigateToPageWithClick ( onSignInOrRegisterButton (), block ) }","title":"Navigate click helper"},{"location":"navigation-dsl/#start-navigation","text":"The start of every test instantiates a new page object and asserts that the screen was show before applying the PageScope . To simplify this task, some logic from the click helper function can be reused. inline fun < reified T : BasePage > startOnPage ( block : PageScope < T > = {}): T = T :: class . java . newInstance (). apply { assertScreen () block () }","title":"Start navigation"},{"location":"navigation-dsl/#navigate-without-interaction","text":"It may be possible that a test will need to navigate to a screen but not interact with that page. So it would be desired to continue navigation without needing to supply another lambda which is simple by using a default argument as an empty lambda in the navigation function. class LoggedInPage : BasePage { fun goToSettings ( block : PageScope < Settings > = {}): SettingsPage = navigateToWithClick ( onSettings (), block ) }","title":"Navigate without interaction"},{"location":"navigation-dsl/#dsl-structure","text":"Putting everything together, the basic of the structure of the navigation DSL would have a test looking like the following: @Test fun successfulLogin () { startOnPage < LoginPage > { // start navigation // this: LoginPage // interact with screen enterInfo ( username , password ) }. goToLoggedInPage { // chained methods navigate to another screen // this: LoggedInPage // or make assertions onBodyText (). verifyText ( \"Welcome Andrew!\" ) }. goToSettings () // default empty scoped lambda can assert navigation to a screen but not interact } Navigation is done with startOnPage() or a function in a page object, which should provides a scoped lambda to the page Each navigation function also returns the page being navigated to in order to chain navigation methods after scoped lambdas View interactions and assertions occur inside of each scoped lambda with the page as its receiver Any PageScope function parameter should provide a default empty lambda so navigation can be asserted, but not require interaction with a screen. The test is starting to look a lot cleaner utilizing the page object pattern, extension functions, and creating a navigation DSL. However the production code is hard coded to get the test to pass and in the next couple sections we will learn about a couple different approaches in making mock tests with more dynamic production looking code.","title":"DSL Structure"},{"location":"navigation-dsl/#references","text":"Source code Github commit 4-navigation-dsl - GitHub branch","title":"References"},{"location":"page-object-pattern/","text":"Page Object Pattern The page object pattern is a very popular design pattern when writing automation tests helping minimize code duplication and test code that is easy to maintain. What is a page object A page object is an object oriented class that is an abstraction over the user interface for an automation test. How to make a page object Quote The basic rule of thumb for a page object is that it should allow a software client to do anything and see anything that a human can. It should also provide an interface that's easy to program to and hides the underlying widgetry in the window. - Martin Fowler Using the rule above, what might be some objects that a user could interact with on each page below? LoginPage LoggedInPage Answer LoginPage email password sign in or register button LoggedInPage profile image greeting text BasePage To start building these page objects, first define an interface that will provide one simple function to assert the screen is visible. This will be essential for the navigation DSL later. interface BasePage { fun assertScreen () } The rest of the page objects may be implemented using the BasePage . Since Espresso is being used to write the tests, every object on each page shall return a ViewInteraction to provide tests an interface for interacting with views. LoginPage class LoginPage : BasePage { override fun assertScreen () = TODO () fun onEmail (): ViewInteraction = TODO () fun onPassword (): ViewInteraction = TODO () fun onSignInOrRegisterButton (): ViewInteraction = TODO () } LoggedInPage class LoggedInPage : BasePage { override fun assertScreen () = TODO () fun onWelcomeGreeting (): ViewInteraction = TODO () fun onProfileImage (): ViewInteraction = TODO () } Simple Test With each page object defined, a successful login test can be written using some Espresso ViewActions to type in the login info and verify the user name after a successful submission. @Test fun successfulLogin () { val scenario = ActivityScenario . launch ( LoginActivity :: class . java ) LoginPage (). apply { onEmail (). perform ( ViewActions . typeText ( \"andrew@test.com\" )) onPassword (). perform ( ViewActions . typeText ( \"password123\" )) onSignInOrRegisterButton (). perform ( ViewActions . click ()) } LoggedInPage (). onWelcomeGreeting (). check ( matches ( withText ( \"Welcome Andrew!\" ))) } As you probably have noticed, none of the functions in the page object have been implemented and the test above is a little verbose. Move onto the next section to learn about some helpful extension functions that simplify implementing the rest of the page object and make the test more expressive. Resources Source code Github Commit 2-page-objects - GitHub branch","title":"Page Object Pattern"},{"location":"page-object-pattern/#page-object-pattern","text":"The page object pattern is a very popular design pattern when writing automation tests helping minimize code duplication and test code that is easy to maintain.","title":"Page Object Pattern"},{"location":"page-object-pattern/#what-is-a-page-object","text":"A page object is an object oriented class that is an abstraction over the user interface for an automation test.","title":"What is a page object"},{"location":"page-object-pattern/#how-to-make-a-page-object","text":"Quote The basic rule of thumb for a page object is that it should allow a software client to do anything and see anything that a human can. It should also provide an interface that's easy to program to and hides the underlying widgetry in the window. - Martin Fowler Using the rule above, what might be some objects that a user could interact with on each page below? LoginPage LoggedInPage Answer LoginPage email password sign in or register button LoggedInPage profile image greeting text","title":"How to make a page object"},{"location":"page-object-pattern/#basepage","text":"To start building these page objects, first define an interface that will provide one simple function to assert the screen is visible. This will be essential for the navigation DSL later. interface BasePage { fun assertScreen () } The rest of the page objects may be implemented using the BasePage . Since Espresso is being used to write the tests, every object on each page shall return a ViewInteraction to provide tests an interface for interacting with views.","title":"BasePage"},{"location":"page-object-pattern/#loginpage","text":"class LoginPage : BasePage { override fun assertScreen () = TODO () fun onEmail (): ViewInteraction = TODO () fun onPassword (): ViewInteraction = TODO () fun onSignInOrRegisterButton (): ViewInteraction = TODO () }","title":"LoginPage"},{"location":"page-object-pattern/#loggedinpage","text":"class LoggedInPage : BasePage { override fun assertScreen () = TODO () fun onWelcomeGreeting (): ViewInteraction = TODO () fun onProfileImage (): ViewInteraction = TODO () }","title":"LoggedInPage"},{"location":"page-object-pattern/#simple-test","text":"With each page object defined, a successful login test can be written using some Espresso ViewActions to type in the login info and verify the user name after a successful submission. @Test fun successfulLogin () { val scenario = ActivityScenario . launch ( LoginActivity :: class . java ) LoginPage (). apply { onEmail (). perform ( ViewActions . typeText ( \"andrew@test.com\" )) onPassword (). perform ( ViewActions . typeText ( \"password123\" )) onSignInOrRegisterButton (). perform ( ViewActions . click ()) } LoggedInPage (). onWelcomeGreeting (). check ( matches ( withText ( \"Welcome Andrew!\" ))) } As you probably have noticed, none of the functions in the page object have been implemented and the test above is a little verbose. Move onto the next section to learn about some helpful extension functions that simplify implementing the rest of the page object and make the test more expressive.","title":"Simple Test"},{"location":"page-object-pattern/#resources","text":"Source code Github Commit 2-page-objects - GitHub branch","title":"Resources"}]}